#version 460

#include "core/struct.glsl"
#include "core/boolean.glsl"

layout(local_size_x = 32) in;

layout(set = 0, binding = 0) uniform readonly GlobalUbo {
  vec3 origin;
  vec3 horizontal;
  vec3 vertical;
  vec3 lowerLeftCorner;
  uvec2 imgSize;
  uint numLights;
} ubo;

layout(set = 0, binding = 1) buffer writeonly ObjectRayUbo {
  RayData rayDatas[];
} objectRayUbo;

layout(set = 0, binding = 2) buffer writeonly LightRayUbo {
  RayData rayDatas[];
} lightRayUbo;

layout(set = 0, binding = 3) buffer readonly SamplerDataUbo {
  IndirectSamplerData samplerDatas[];
} samplerDataUbo;

layout(push_constant) uniform Push {
  uint randomSeed;
} push;

void main() {
  IndirectSamplerData samplerData = samplerDataUbo.samplerDatas[gl_GlobalInvocationID.x];

  vec2 uv = vec2(samplerData.xCoord, samplerData.yCoord) / ubo.imgSize;
  vec3 rayDirection = ubo.lowerLeftCorner + uv.x * ubo.horizontal - uv.y * ubo.vertical - ubo.origin;

  Ray curRay;

  curRay.origin = mix(ubo.origin, samplerData.nextRay.origin, when_gt(samplerData.rayBounce, 0.9f));
  curRay.direction = mix(rayDirection, samplerData.nextRay.direction, when_gt(samplerData.rayBounce, 0.9f));
  curRay.primitiveId = samplerData.nextRay.primitiveId * uint(when_gt(samplerData.rayBounce, 0.9f));

  RayData rayData;
  rayData.ray = curRay;
  rayData.dirMin = 0.01f;
  rayData.dirMax = vec3(1000000000000.0f);
  rayData.rayBounce = round(samplerData.rayBounce);

  objectRayUbo.rayDatas[gl_GlobalInvocationID.x] = rayData;
  lightRayUbo.rayDatas[gl_GlobalInvocationID.x] = rayData;
}



