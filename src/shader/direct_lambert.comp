#version 460

#include "core/struct.glsl"
#include "core/boolean.glsl"

layout(local_size_x = 32) in;

layout(set = 0, binding = 0) buffer writeonly DirectUbo {
  DirectShadeRecord records[];
} directUbo;

layout(set = 0, binding = 1) buffer readonly ObjectHitUbo {
  HitRecord records[];
} objectHitUbo;

layout(set = 0, binding = 2) buffer readonly LightHitUbo {
  HitRecord records[];
} lightHitUbo;

layout(set = 0, binding = 3) buffer readonly DirectDataUbo {
  DirectData datas[];
} directDataUbo;

layout(set = 0, binding = 4) buffer readonly MaterialSsbo {
  Material materials[];
};

layout(set = 0, binding = 5) buffer readonly LightSsbo {
  TriangleLight lights[];
};

layout(set = 0, binding = 6) buffer readonly VertexSsbo {
  Vertex vertices[];
};

layout(set = 0, binding = 7) uniform sampler2D colorTextureSampler[1];

layout(push_constant) uniform Push {
  uint randomSeed;
} push;

// ------------- Basic -------------

vec3 rayAt(Ray r, float t) {
  return r.origin + t * r.direction;
}

vec3[3] buildOnb(vec3 normal) {
  vec3 a = abs(normalize(normal).x) > 0.9 ? vec3(0.0f, 1.0f, 0.0f) : vec3(1.0f, 0.0f, 0.0f);

  vec3 z = normalize(normal);
  vec3 y = normalize(cross(z, a));
  vec3 x = cross(z, y);

  return vec3[3](x, y, z);
}

// ------------- Integrand ------------- 

vec3 integrandOverHemisphere(vec3 color, float brdf, float NoL, float pdf) {
  return color * brdf * NoL / pdf; 
}

vec3 integrandOverArea(vec3 color, float brdf, float NoL, float NloL, float squareDistance, float area) {
  return color * brdf * NoL * NloL * area / squareDistance;
}

vec3 partialIntegrand(vec3 color, float brdf, float NoL) {
  return color * brdf * NoL;
}

float Gfactor(float NloL, float squareDistance, float area) {
  return NloL * area / squareDistance;
}

// ------------- Random ------------- 

// Random number generation using pcg32i_random_t, using inc = 1. Our random state is a uint.
uint stepRNG(uint rngState) {
  return rngState * 747796405 + 1;
}

// Steps the RNG and returns a floating-point value between 0 and 1 inclusive.
float stepAndOutputRNGFloat(inout uint rngState) {
  // Condensed version of pcg_output_rxs_m_xs_32_32, with simple conversion to floating-point [0,1].
  rngState  = stepRNG(rngState);
  uint word = ((rngState >> ((rngState >> 28u) + 4u)) ^ rngState) * 277803737u;
  word      = (word >> 22u) ^ word;
  return float(word) / 4294967295.0f;
}

float randomFloat(uint additionalRandomSeed) {
  uint rngState =  gl_GlobalInvocationID.x * (push.randomSeed + 1 + additionalRandomSeed);
  return stepAndOutputRNGFloat(rngState);
}

// ------------- Lambert ------------- 

vec3 randomCosineDirection(uint additionalRandomSeed) {
  float r1 = randomFloat(additionalRandomSeed);
  float r2 = randomFloat(additionalRandomSeed + 1);

  float cosTheta = sqrt(r1);
  float sinTheta = sqrt(1.0f - cosTheta * cosTheta);
  
  float phi = 2 * pi * r2;

  float x = cos(phi) * sinTheta;
  float y = sin(phi) * sinTheta;
  float z = cosTheta;

  return vec3(x, y, z);
}

vec3 lambertRandomDirection(vec3[3] globalOnb, uint additionalRandomSeed) {
  vec3 source = randomCosineDirection(additionalRandomSeed);
  return source.x * globalOnb[0] + source.y * globalOnb[1] + source.z * globalOnb[2];
}

float lambertPdfValue(float NoL) {
  return max(NoL / pi, 0.001f);
}

float lambertBrdfValue() {
  return 1.0f / pi;
}

// ------------- Triangle -------------

float triangleArea(uvec3 triIndices) {
  vec3 v0v1 = vertices[triIndices.y].position - vertices[triIndices.x].position;
  vec3 v0v2 = vertices[triIndices.z].position - vertices[triIndices.x].position;

  vec3 pvec = cross(v0v1, v0v2);
  return 0.5 * sqrt(dot(pvec, pvec)); 
}

// ------------- Shade ------------- 

DirectShadeRecord directLambertShade(HitRecord lightHit, vec3 surfaceColor, vec3 surfaceNormal, uint additionalRandomSeed) {
  vec3 unitLightDirection = normalize(lightHit.dir);
  DirectShadeRecord scat;

  float NloL = max(dot(lightHit.normal, -1.0f * unitLightDirection), 0.001f);
  float NoL = max(dot(surfaceNormal, unitLightDirection), 0.001f);

  float brdf = lambertBrdfValue();
  float sqrDistance = dot(lightHit.dir, lightHit.dir);
  float area = triangleArea(lights[lightHit.hitIndex].indices);
  float pdf = lambertPdfValue(NoL);

  scat.radiance = partialIntegrand(surfaceColor, brdf, NoL) * Gfactor(NloL, sqrDistance, area) * lights[lightHit.hitIndex].color;
  scat.pdf = when_gt(length(scat.radiance), 0.1f) * pdf;

  return scat;
}

DirectShadeRecord directLambertShade(HitRecord lightHit, DirectData directData, uint additionalRandomSeed) {
  vec3 surfaceColor;
  if (materials[directData.materialIndex].colorTextureIndex == 0u) {
    surfaceColor = materials[directData.materialIndex].baseColor;
  } else {
    surfaceColor = texture(colorTextureSampler[materials[directData.materialIndex].colorTextureIndex - 1u], directData.uv).xyz;
  }

  return directLambertShade(lightHit, surfaceColor, directData.normal, additionalRandomSeed);
}

void main() {
  HitRecord objectHit = objectHitUbo.records[gl_GlobalInvocationID.x];
  HitRecord lightHit = lightHitUbo.records[gl_GlobalInvocationID.x];
  DirectData directData = directDataUbo.datas[gl_GlobalInvocationID.x];

  float isHitLight = when_and(when_gt(lightHit.isHit, 0.9f), when_or(when_lt(objectHit.isHit, 0.1f), when_lt(length(lightHit.dir), length(objectHit.dir))));
  
  DirectShadeRecord directShadeResult = directLambertShade(lightHit, directData, 0u);
  directShadeResult.isIlluminate = directData.isIlluminate * isHitLight;
  
  directUbo.records[gl_GlobalInvocationID.x] = directShadeResult;
}